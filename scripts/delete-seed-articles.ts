/**
 * Delete ALL articles from production.
 * Run with: npx tsx scripts/delete-seed-articles.ts
 *
 * This permanently removes all seed/fake data. Real articles will be
 * generated by the article generator from actual ingested documents.
 */

import { getSupabaseServiceClient } from '../src/lib/supabase';

async function deleteSeedArticles() {
  console.log('ðŸ—‘ï¸  Deleting all articles from production...\n');

  const supabase = getSupabaseServiceClient();

  // Count first
  const { count, error: countError } = await supabase
    .from('articles')
    .select('*', { count: 'exact', head: true });

  if (countError) {
    console.error('âŒ Error counting articles:', countError);
    process.exit(1);
  }

  console.log(`Found ${count ?? 0} articles in database.`);

  if (!count || count === 0) {
    console.log('âœ… Table is already empty â€” nothing to delete.');
    return;
  }

  // Delete all rows by filtering on a condition that matches everything
  // (Supabase requires a filter on DELETE to prevent accidental full-table deletion;
  //  using status IN ('draft','published','archived') covers all valid values)
  const { error: deleteError } = await supabase
    .from('articles')
    .delete()
    .in('status', ['draft', 'published', 'archived']);

  if (deleteError) {
    console.error('âŒ Error deleting articles:', deleteError);
    process.exit(1);
  }

  // Verify table is empty
  const { count: remaining, error: verifyError } = await supabase
    .from('articles')
    .select('*', { count: 'exact', head: true });

  if (verifyError) {
    console.error('âŒ Error verifying deletion:', verifyError);
    process.exit(1);
  }

  if (remaining && remaining > 0) {
    console.error(`âŒ Table still has ${remaining} rows after deletion!`);
    process.exit(1);
  }

  console.log(`âœ… Successfully deleted ${count} articles.`);
  console.log('âœ… Articles table is now empty and ready for real content.');
}

deleteSeedArticles().catch((error) => {
  console.error('Fatal error:', error);
  process.exit(1);
});
